#!/usr/bin/env python3
"""
A command-line tool to analyze a chess game from a PGN file using Stockfish.

This script reads a PGN from standard input and uses a continuous analysis
model, letting the engine think for a set amount of time on each move and
providing live feedback on the search depth.

Usage:
  cat my_game.pgn | python3 this_script.py
  cat my_game.pgn | python3 this_script.py --think-time 5
"""

import argparse
import sys
import time
from io import StringIO
import chess.pgn
import chess.engine

# === CONFIGURATION ===
STOCKFISH_PATH = "stockfish"

def _get_eval_in_pawns(score_pov):
    """Converts a chess.engine.PovScore to a float pawn value, clamping mates."""
    if score_pov.is_mate():
        mate_in = score_pov.mate()
        return 100.0 if mate_in > 0 else -100.0
    else:
        return score_pov.score(mate_score=10000) / 100.0

def _get_continuous_analysis(engine, board, think_time):
    """
    Performs continuous analysis on a board position for a set duration.

    Args:
        engine: The chess.engine.SimpleEngine instance.
        board: The chess.Board to analyze.
        think_time (float): The number of seconds to analyze the position.

    Returns:
        tuple: (final_score, best_move_found)
    """
    final_score = 0.0
    best_move_found = None
    
    # engine.analysis() returns a stream of info objects
    with engine.analysis(board) as analysis:
        start_time = time.time()
        for info in analysis:
            # Print live updates to stderr (so it doesn't mess with final output)
            if "depth" in info and "score" in info:
                score = _get_eval_in_pawns(info["score"].relative)
                # Using \r (carriage return) to print on the same line
                print(f"  ... thinking, depth: {info['depth']:<2}, eval: {score:+.2f}", end='\r', file=sys.stderr)

            # Keep the latest score and principal variation (best line of moves)
            if "score" in info:
                final_score = _get_eval_in_pawns(info["score"].relative)
            if "pv" in info:
                best_move_found = info["pv"][0]

            # Stop analyzing when the think time is up
            if time.time() - start_time > think_time:
                break
    
    # Clear the "thinking" line from stderr
    print(" " * 60, end='\r', file=sys.stderr)
    return final_score, best_move_found


def analyze_game_from_pgn(pgn_content, think_time=2.0):
    """
    Analyzes a chess game from PGN content using a continuous Stockfish analysis.
    """
    try:
        pgn_io = StringIO(pgn_content)
        game = chess.pgn.read_game(pgn_io)
        if not game:
            return {"error": "Failed to parse PGN content. Please provide a valid PGN."}

        with chess.engine.SimpleEngine.popen_uci(STOCKFISH_PATH) as engine:
            board = game.board()
            moves_analysis = []
            big_drops = []
            
            headers = game.headers
            game_info = {
                "event": headers.get("Event", "PGN Game"),
                "white": headers.get("White", "?"),
                "black": headers.get("Black", "?"),
            }

            for next_node in game.mainline():
                move_num_str = f"{board.fullmove_number}{'.' if board.turn == chess.WHITE else '...'}"
                print(f"Analyzing move {move_num_str} {board.san(next_node.move)}...", file=sys.stderr)

                # === 1. Evaluate BEFORE the move ===
                score_before, best_move_before = _get_continuous_analysis(engine, board, think_time)
                
                san_played = board.san(next_node.move)
                san_best = board.san(best_move_before) if best_move_before else "N/A"

                # Apply the move
                board.push(next_node.move)

                # === 2. Evaluate AFTER the move ===
                score_after_opponent_pov, _ = _get_continuous_analysis(engine, board, think_time)
                
                # Flip the score back to the original player's perspective for comparison
                score_after_player_pov = -score_after_opponent_pov
                eval_drop = score_before - score_after_player_pov
                
                current_move_number = f"{board.fullmove_number-1}..." if board.turn == chess.BLACK else board.fullmove_number
                
                moves_analysis.append({
                    "move_number": current_move_number,
                    "san": san_played,
                    "eval_before": score_before,
                    "eval_after": score_after_player_pov,
                })
                
                # Track significant drops
                if eval_drop >= 2.0 and next_node.move != best_move_before:
                    big_drops.append({
                        "move_number": current_move_number,
                        "played": san_played,
                        "best": san_best,
                        "eval_before": score_before,
                        "eval_after": score_after_player_pov,
                        "delta": eval_drop,
                    })

            return {
                "game_info": game_info,
                "moves_analysis": moves_analysis,
                "big_drops": big_drops,
            }

    except Exception as e:
        return {"error": f"An unexpected error occurred: {e}"}


def format_analysis_output(analysis, pgn_filename="game.pgn"):
    """Formats the analysis dictionary into a human-readable string."""
    # This function remains largely the same, but I've updated it slightly
    # for better formatting of move numbers.
    if "error" in analysis:
        return f"Error: {analysis['error']}"

    output = []
    game_info = analysis["game_info"]
    game_title = game_info.get("event") if game_info.get("event") != "?" else pgn_filename
    output.append(f"ðŸ“‚ Game: {game_title} ({game_info['white']} vs. {game_info['black']})")
    output.append("-" * 40)

    for move in analysis["moves_analysis"]:
        eval_before_str = f"{move['eval_before']:>5.2f}"
        eval_after_str = f"{move['eval_after']:>5.2f}"
        move_line = f"Move {str(move['move_number']):<5s}: {move['san']:<7s} | Eval: {eval_before_str} â†’ {eval_after_str}"
        output.append(move_line)

    output.append("")

    if analysis["big_drops"]:
        output.append("âš ï¸  Significant Evaluation Drops (Blunders):")
        for drop in analysis["big_drops"]:
            drop_line = (
                f"  Move {str(drop['move_number']):<5s}: Played {drop['played']}, but best was {drop['best']}. "
                f"Eval dropped from {drop['eval_before']:.2f} to {drop['eval_after']:.2f} (Î” = {drop['delta']:.2f})"
            )
            output.append(drop_line)
    else:
        output.append("âœ… No major blunders detected.")

    return "\n".join(output)


def main():
    """Main function to handle command-line arguments and script execution."""
    parser = argparse.ArgumentParser(description="Analyze a chess game from PGN using continuous analysis.")
    parser.add_argument(
        "--think-time",
        type=float,
        default=2.0,
        help="Seconds to let the engine think on each half-move (default: 2.0).",
    )
    args = parser.parse_args()

    print(f"ðŸ” Continuous analysis mode ({args.think_time}s per move)", file=sys.stderr)

    pgn_content = sys.stdin.read().strip()
    if not pgn_content:
        print("Error: No PGN content provided to standard input.", file=sys.stderr)
        sys.exit(1)

    analysis = analyze_game_from_pgn(pgn_content, args.think_time)
    print("\n" + "="*40 + "\nANALYSIS COMPLETE\n" + "="*40, file=sys.stderr)
    print(format_analysis_output(analysis))


if __name__ == "__main__":
    main()